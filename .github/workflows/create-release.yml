name: Create Release with Branch Archives

on:
  workflow_dispatch: # Manual trigger

# Add permissions block at the workflow level
permissions:
  contents: write # Required for creating releases and uploading assets
  actions: read # Required for workflow access

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches

      - name: Verify Git setup
        run: |
          echo "Verifying Git setup..."
          git --version
          git branch -a
          git remote -v
          echo "Git setup verified successfully"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Extract version from package.json
        id: version
        run: |
          if [ ! -f package.json ]; then
            echo "Error: package.json not found"
            exit 1
          fi
          version=$(node -p "require('./package.json').version")
          if [ -z "$version" ] || [ "$version" = "undefined" ]; then
            echo "Error: Could not extract version from package.json"
            exit 1
          fi
          echo "version=$version" >> $GITHUB_ENV
          echo "Extracted version: $version"

      - name: Create output directory
        run: |
          mkdir -p "out/${{ env.version }}"
          echo "Created output directory: out/${{ env.version }}"

      - name: Zip branches
        run: |
          # Save the current branch name
          current_branch=$(git rev-parse --abbrev-ref HEAD)
          if [ -z "$current_branch" ]; then
            echo "Error: Could not determine current branch"
            exit 1
          fi
          echo "Current branch: $current_branch"

          # Check for existing .zipignore file
          if [ -f .zipignore ]; then
            echo "Using existing .zipignore file:"
            cat .zipignore
          else
            echo "Creating default .zipignore file..."
            
            # Version control and CI/CD files
            echo ".git/" > .zipignore
            echo ".github/" >> .zipignore
            
            # Dependencies and build artifacts
            echo "node_modules/" >> .zipignore
            echo ".next/" >> .zipignore
            echo "out/" >> .zipignore
            
            # Temporary and working directories
            echo "temp_zip_dir/" >> .zipignore
            
            # Log files
            echo "*.log" >> .zipignore
            
            # Environment and configuration files
            echo ".env*" >> .zipignore
            
            # OS-specific files
            echo ".DS_Store" >> .zipignore
            echo "Thumbs.db" >> .zipignore
            echo ".zipignore" >> .zipignore
            
            echo "Created default .zipignore file"
          fi

          # Function to zip non-gitignored files for a branch
          zip_branch() {
            local branch=$1
            local zip_name="out/${{ env.version }}/${branch}.zip"
            local temp_dir="temp_zip_dir"
            
            echo "Processing branch: $branch"
            
            # Clean temp dir
            rm -rf "$temp_dir"
            mkdir -p "$temp_dir"

            # Checkout branch with error handling
            if ! git checkout "$branch" 2>/dev/null; then
              echo "Warning: Could not checkout branch $branch, skipping..."
              rm -rf "$temp_dir"
              return 1
            fi

            echo "Zipping branch: $branch -> $zip_name"

            # Use rsync to copy files, excluding patterns from .zipignore and .gitignore
            # This ensures .zipignore files are properly respected during the zip process
            local rsync_excludes=""
            if [ -f .zipignore ]; then
              rsync_excludes="$rsync_excludes --exclude-from=.zipignore"
              echo "Applying .zipignore exclusions for branch $branch"
            fi
            if [ -f .gitignore ]; then
              rsync_excludes="$rsync_excludes --exclude-from=.gitignore"
              echo "Applying .gitignore exclusions for branch $branch"
            fi

            echo "Copying files for branch $branch (excluding ignored patterns)..."
            if ! rsync -a $rsync_excludes ./ "$temp_dir/"; then
              echo "Error: Failed to copy files for branch $branch"
              rm -rf "$temp_dir"
              return 1
            fi
            echo "Files copied successfully for branch $branch"

            echo "Creating zip archive for branch $branch..."
            # Create zip from temp dir
            if ! (cd "$temp_dir" && zip -qr "../$zip_name" .); then
              echo "Error: Failed to create zip for branch $branch"
              rm -rf "$temp_dir"
              return 1
            fi

            echo "âœ… Successfully created: $zip_name"
            
            # Clean up
            rm -rf "$temp_dir"
            return 0
          }

          # Zip current branch
          echo "ðŸ”„ Processing current branch: $current_branch"
          if ! zip_branch "$current_branch"; then
            echo "Error: Failed to zip current branch"
            exit 1
          fi
          echo "âœ… Current branch processed successfully"

          # Get all origin branches except the current one, HEAD, and origin
          echo "ðŸ” Discovering additional branches..."
          echo "Debug: All remote refs:"
          git for-each-ref --format='%(refname:short)' refs/remotes/origin/ || echo "Warning: Could not list remote refs"

          branches=$(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | sed 's/origin\///' | grep -v "^$current_branch$" | grep -v "^HEAD$" | grep -v "^origin$" | grep -v "^$" | tr '\n' ' ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          # Handle case where no additional branches are found
          if [ -z "$branches" ] || [ "$branches" = "" ]; then
            echo "ðŸ“‹ No additional branches found - only processing current branch ($current_branch)"
            branches=""
          else
            echo "ðŸ“‹ Found additional branches: $branches"
          fi

          # Ensure we always have at least the current branch to process
          if [ -z "$branches" ]; then
            echo "â„¹ï¸  Proceeding with single branch release (current branch only)"
          fi

          # Iterate over origin branches
          failed_branches=""

          if [ -n "$branches" ] && [ "$branches" != "" ]; then
            branch_count=$(echo "$branches" | wc -w)
            current_branch_num=0
            
            if [ "$branch_count" -gt 0 ]; then
              echo "ðŸ”„ Processing $branch_count additional branches..."
              for branch in $branches; do
                current_branch_num=$((current_branch_num + 1))
                echo "ðŸ“¦ [$current_branch_num/$branch_count] Processing branch: $branch"
                if ! zip_branch "$branch"; then
                  failed_branches="$failed_branches $branch"
                  echo "âŒ Failed to process branch: $branch"
                else
                  echo "âœ… Successfully processed branch: $branch"
                fi
              done
              echo "ðŸ Finished processing all additional branches"
            fi
          else
            echo "â„¹ï¸  No additional branches to process - only main branch will be released"
            branch_count=0
          fi

          # Return to the original branch
          echo "ðŸ”„ Returning to original branch: $current_branch"
          git checkout "$current_branch"
          echo "âœ… Returned to original branch: $current_branch"

          # Report any failed branches
          if [ -n "$failed_branches" ]; then
            echo "âš ï¸  Warning: Failed to process branches:$failed_branches"
            # Don't exit with error if we at least processed the current branch successfully
            if [ "$branch_count" -eq 0 ]; then
              echo "â„¹ï¸  Current branch was processed successfully, continuing with release..."
            fi
          else
            echo "ðŸŽ‰ All branches processed successfully!"
          fi

          # Calculate total branches processed
          if [ "$branch_count" -gt 0 ]; then
            total_branches=$((branch_count + 1))
            echo "ðŸ“Š Summary: Processed $total_branches total branches (1 current + $branch_count additional)"
          else
            echo "ðŸ“Š Summary: Processed 1 branch (current branch only)"
          fi

      - name: Verify zip files
        run: |
          echo "Created zip files:"
          ls -la "out/${{ env.version }}/"

          # Check if we have at least one zip file
          if [ ! "$(ls -A "out/${{ env.version }}/"*.zip 2>/dev/null)" ]; then
            echo "Error: No zip files were created"
            exit 1
          fi

      - name: Create Release
        run: |
          echo "Creating release v${{ env.version }}"
          gh release create "v${{ env.version }}" \
            --title "v${{ env.version }}" \
            --notes "Release with branch archives" \
            --draft=false \
            --prerelease=false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Release Assets
        run: |
          echo "Uploading release assets..."
          for zip_file in out/${{ env.version }}/*.zip; do
            if [ -f "$zip_file" ]; then
              echo "Uploading $zip_file"
              if ! gh release upload v${{ env.version }} "$zip_file" --clobber; then
                echo "Error: Failed to upload $zip_file"
                exit 1
              fi
              echo "Successfully uploaded $zip_file"
            fi
          done
          echo "All assets uploaded successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up temporary files..."
          rm -rf "out/${{ env.version }}"
          rm -rf temp_zip_dir
          echo "Cleanup completed"
